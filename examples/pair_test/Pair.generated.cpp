/*
---- WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING  ----
---- ANY MANUAL CHANGES IN THIS FILE WILL DISAPPEAR IF YOU REGENERATE ----
--------------------------------------------------------------------------
 This file has been generated by http://github.com/fnchooft/CStructGen
--------------------------------------------------------------------------
 Package: @PACKAGE_NAME@
 Version: @PACKAGE_VERSION@
 Sha1sum: 6e24380b524dc013196603a01df401b2d7ca2769  Pair.hpp
--------------------------------------------------------------------------
 Make sure to update the originating Pair.hpp-file
--------------------------------------------------------------------------
---- WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING  ----
---- ANY MANUAL CHANGES IN THIS FILE WILL DISAPPEAR IF YOU REGENERATE ----
*/
#ifndef __IMPLEMENTATION_PAIR_HPP__
#define __IMPLEMENTATION_PAIR_HPP__


#ifdef __cplusplus


#include "Pair.generated.h"
#include <stdio.h>
#include <string.h>
#include "jsonxx.h"

// Generated default printers for struct: SPairSecond
std::ostream & operator<<(std::ostream & out, const SPairSecond & spairsecond) {
    out << "pairtype:"   << " "  << spairsecond.pairtype          << ", ";
    out << "astring:"    << " "  << spairsecond.astring           << "";
    return out;
}


std::string toString(const SPairSecond & spairsecond) {
    std::stringstream out;
    std::string ret = "";
    out << spairsecond;
    ret = out.str();
    return ret;
}


// struct: SPairSecond compare-functions due to union existance...
// Found Struct->settings.... 0
// Generated default compare implementation for struct: SPairSecond
bool operator<(SPairSecond lhs, SPairSecond rhs) {
    if (lhs.pairtype   < rhs.pairtype)   return true;
    if (lhs.pairtype   > rhs.pairtype)   return false;
    if (lhs.astring    < rhs.astring)    return true;
    if (lhs.astring    > rhs.astring)    return false;
    return false;
}
bool operator<=(SPairSecond lhs, SPairSecond rhs) {
    if ((lhs < rhs) || (lhs == rhs)){
        return true;
    } else {
        return false;
    }
}
bool operator>(SPairSecond lhs, SPairSecond rhs) {
    return !(lhs <= rhs);
}
bool operator>=(SPairSecond lhs, SPairSecond rhs) {
    return !(lhs < rhs);
}
bool operator==(SPairSecond lhs, SPairSecond rhs){
    if (lhs.pairtype   != rhs.pairtype)   return false;
    if (lhs.astring    != rhs.astring)    return false;
    return true;
}
bool operator!=(SPairSecond lhs, SPairSecond rhs) {
    return !(lhs == rhs);
}


// Generated toJsonString / fromJsonString implementation for struct: SPairSecond
std::string toJsonString(SPairSecond *input) {
  jsonxx::Object jsono;
  jsono << "pairtype" << (int)input->pairtype;
  jsono << "astring" << (std::string)input->astring;
  return jsono.json();
}


int32_t fromJson(SPairSecond *output, std::string jsondata) {
  jsonxx::Object json;
  if(!json.parse(jsondata))
  {
    return -2048;
  }
  if(json.has<jsonxx::Number>("pairtype"))
  {
    output->pairtype = (int)json.get<jsonxx::Number>("pairtype");
  }
  if(json.has<jsonxx::String>("astring"))
  {
    output->astring = (std::string)json.get<jsonxx::String>("astring");
  }
  return 0;
}
//Generated default toString,fromString,stream implementations for enumeration: EPairType
std::string toString(EPairType enumval, int32_t shortname)
{
  if(enumval == LOCAL){
    return shortname == 0 ? "LOCAL"       : "local";
  }
  if(enumval == GLOBAL){
    return shortname == 0 ? "GLOBAL"      : "global";
  }
  return shortname == 0 ? "??????" : "???";
} // toString for EPairType


bool fromString(std::string svalue, EPairType *enum_ptr)
{
  if(svalue == "LOCAL"       || svalue == "local")            {
    *enum_ptr = LOCAL;       return true;
  }
  if(svalue == "GLOBAL"      || svalue == "global")           {
    *enum_ptr = GLOBAL;      return true;
  }
  return false;
} // EPairType_fromString


std::ostream & operator<<(std::ostream & out, const EPairType epairtype)
{
  out << toString(epairtype);
  return out;
} // EPairType stream-operator



// Generated default printers for struct: SPair
std::ostream & operator<<(std::ostream & out, const SPair & spair) {
    out << "an_int:"     << " "  << spair.an_int                  << ", ";
    out << "apair:" << " first[" << spair.apair.first << "] ";
    out                  << " second[" << spair.apair.second << "]";
    out << "";
    return out;
}


std::string toString(const SPair & spair) {
    std::stringstream out;
    std::string ret = "";
    out << spair;
    ret = out.str();
    return ret;
}


// struct: SPair compare-functions due to union existance...
// Found Struct->settings.... 0
// Generated default compare implementation for struct: SPair
bool operator<(SPair lhs, SPair rhs) {
    if (lhs.an_int     < rhs.an_int)     return true;
    if (lhs.an_int     > rhs.an_int)     return false;
    if (lhs.apair      < rhs.apair)      return true;
    if (lhs.apair      > rhs.apair)      return false;
    return false;
}
bool operator<=(SPair lhs, SPair rhs) {
    if ((lhs < rhs) || (lhs == rhs)){
        return true;
    } else {
        return false;
    }
}
bool operator>(SPair lhs, SPair rhs) {
    return !(lhs <= rhs);
}
bool operator>=(SPair lhs, SPair rhs) {
    return !(lhs < rhs);
}
bool operator==(SPair lhs, SPair rhs){
    if (lhs.an_int     != rhs.an_int)     return false;
    if (lhs.apair      != rhs.apair)      return false;
    return true;
}
bool operator!=(SPair lhs, SPair rhs) {
    return !(lhs == rhs);
}


// Generated toJsonString / fromJsonString implementation for struct: SPair
std::string toJsonString(SPair *input) {
  jsonxx::Object jsono;
  jsono << "an_int" << (int)input->an_int;
  // Pair handling Field->Struct->Field.first && Field.second
  jsonxx::Object apair_pair_object;
  apair_pair_object << "first" << (bool)input->apair.first;
  jsonxx::Object apair_second_object;
  if(apair_second_object.parse(toJsonString(&input->apair.second)) != 1)
    return "BROKEN second_object";
  apair_pair_object << "second" << apair_second_object;
  jsono << "apair" << apair_pair_object;
  return jsono.json();
}


int32_t fromJson(SPair *output, std::string jsondata) {
  jsonxx::Object json;
  if(!json.parse(jsondata))
  {
    return -2048;
  }
  if(json.has<jsonxx::Number>("an_int"))
  {
    output->an_int = (int)json.get<jsonxx::Number>("an_int");
  }
  // Pair-implementation deserializes into an Object.
  if(json.has<jsonxx::Object>("apair"))
  {
    jsonxx::Object apair_object = json.get<jsonxx::Object>("apair");

    // First  is of type bool                 FundamentalType       json_type: Boolean
    // Second is of type SPairSecond Struct json_type: Object
    bool apair_first = apair_object.get<jsonxx::Boolean>("first");
    SPairSecond apair_second;
    if(fromJson(&apair_second, apair_object.get<jsonxx::Object>("second").json()) != 0)
    {
      return -2;
    }
    output->apair = std::make_pair(apair_first,apair_second);
  }
  return 0;
}

// Generated default printers for struct: SMapTest
std::ostream & operator<<(std::ostream & out, const SMapTest & smaptest) {
    out << "amap:" << " [ ";
    for (
         std::map<bool,SPairSecond >::const_iterator it=smaptest.amap.begin();
         it != smaptest.amap.end();
         ++it
	     )
    {
      out << it->first << ":" << it->second;
      if(it != smaptest.amap.end())
        out << ",";
    }
    out << " ] " << "";
    return out;
}


std::string toString(const SMapTest & smaptest) {
    std::stringstream out;
    std::string ret = "";
    out << smaptest;
    ret = out.str();
    return ret;
}


// struct: SMapTest compare-functions due to union existance...
// Found Struct->settings.... 0
// Generated default compare implementation for struct: SMapTest
bool operator<(SMapTest lhs, SMapTest rhs) {
    if (lhs.amap       < rhs.amap)       return true;
    if (lhs.amap       > rhs.amap)       return false;
    return false;
}
bool operator<=(SMapTest lhs, SMapTest rhs) {
    if ((lhs < rhs) || (lhs == rhs)){
        return true;
    } else {
        return false;
    }
}
bool operator>(SMapTest lhs, SMapTest rhs) {
    return !(lhs <= rhs);
}
bool operator>=(SMapTest lhs, SMapTest rhs) {
    return !(lhs < rhs);
}
bool operator==(SMapTest lhs, SMapTest rhs){
    if (lhs.amap       != rhs.amap)       return false;
    return true;
}
bool operator!=(SMapTest lhs, SMapTest rhs) {
    return !(lhs == rhs);
}


// Generated toJsonString / fromJsonString implementation for struct: SMapTest
std::string toJsonString(SMapTest *input) {
  jsonxx::Object jsono;
  jsonxx::Array jsonm_amap;
  for (
       std::map<bool,SPairSecond >::iterator it=input->amap.begin();
       it != input->amap.end();
       ++it
      )
  {
    jsonxx::Object map_entry;
  map_entry << "key" << (bool)it->first;
  jsonxx::Object MapVal_amap_object;
  if(MapVal_amap_object.parse(toJsonString(&it->second)) != 1)
    return "BROKEN amap_object";
  map_entry << "val" << MapVal_amap_object;
    jsonm_amap << map_entry;
  }
  jsono << "amap" << jsonm_amap;
  return jsono.json();
}


int32_t fromJson(SMapTest *output, std::string jsondata) {
  jsonxx::Object json;
  if(!json.parse(jsondata))
  {
    return -2048;
  }
  if(json.has<jsonxx::Array>("amap"))
  {
    jsonxx::Array amap_map_array = json.get<jsonxx::Array>("amap");
    for(int af = 0; af < amap_map_array.size(); af++)
    {
      jsonxx::Object amap_map_array_entry = amap_map_array.get<jsonxx::Object>(af);
      bool map_key;
      SPairSecond map_val;
      if(amap_map_array_entry.has<jsonxx::Boolean>("key"))
      {
        map_key = amap_map_array_entry.get<jsonxx::Boolean>("key");
      }
      if(amap_map_array_entry.has<jsonxx::Object>("val"))
      {
        if(fromJson(&map_val, amap_map_array_entry.get<jsonxx::Object>("val").json()) != 0)
        {
          return -1;
        }
      }
      output->amap[map_key] = map_val;
    }
  }
  return 0;
}

// Generated default printers for struct: SVectorEnumTest
std::ostream & operator<<(std::ostream & out, const SVectorEnumTest & svectorenumtest) {
    out << "types:" << " [ ";
    for (std::vector<EPairType >::const_iterator it=svectorenumtest.types.begin(); it != svectorenumtest.types.end(); ++it)
    {
      out << *it;
      if(it != svectorenumtest.types.end())
        out << ",";
    }
    out << " ] " << "";
    return out;
}


std::string toString(const SVectorEnumTest & svectorenumtest) {
    std::stringstream out;
    std::string ret = "";
    out << svectorenumtest;
    ret = out.str();
    return ret;
}


// struct: SVectorEnumTest compare-functions due to union existance...
// Found Struct->settings.... 0
// Generated default compare implementation for struct: SVectorEnumTest
bool operator<(SVectorEnumTest lhs, SVectorEnumTest rhs) {
    if (lhs.types      < rhs.types)      return true;
    if (lhs.types      > rhs.types)      return false;
    return false;
}
bool operator<=(SVectorEnumTest lhs, SVectorEnumTest rhs) {
    if ((lhs < rhs) || (lhs == rhs)){
        return true;
    } else {
        return false;
    }
}
bool operator>(SVectorEnumTest lhs, SVectorEnumTest rhs) {
    return !(lhs <= rhs);
}
bool operator>=(SVectorEnumTest lhs, SVectorEnumTest rhs) {
    return !(lhs < rhs);
}
bool operator==(SVectorEnumTest lhs, SVectorEnumTest rhs){
    if (lhs.types      != rhs.types)      return false;
    return true;
}
bool operator!=(SVectorEnumTest lhs, SVectorEnumTest rhs) {
    return !(lhs == rhs);
}


// Generated toJsonString / fromJsonString implementation for struct: SVectorEnumTest
std::string toJsonString(SVectorEnumTest *input) {
  jsonxx::Object jsono;
  jsonxx::Array jsona_types;
  for (std::vector<EPairType >::iterator it=input->types.begin(); it != input->types.end(); ++it)
  {
    jsona_types << (std::string)toString(*it);
  }
  jsono << "types" << jsona_types;
  return jsono.json();
}


int32_t fromJson(SVectorEnumTest *output, std::string jsondata) {
  jsonxx::Object json;
  if(!json.parse(jsondata))
  {
    return -2048;
  }
  if(json.has<jsonxx::Array>("types"))
  {
    jsonxx::Array types_array = json.get<jsonxx::Array>("types");
    for(int af = 0; af < types_array.size(); af++)
    {
      EPairType types_af;
      // Fraq - enumeration is false/true not 0/1
      if(fromString(types_array.get<jsonxx::String>(af),&types_af) == false)
      {
        return -1;
      }
      output->types.push_back(types_af);
    }
  }
  return 0;
}

// Generated default printers for struct: SGmplsTest
std::ostream & operator<<(std::ostream & out, const SGmplsTest & sgmplstest) {
    out << "type:"       << " "  << sgmplstest.type               << "";
    return out;
}


std::string toString(const SGmplsTest & sgmplstest) {
    std::stringstream out;
    std::string ret = "";
    out << sgmplstest;
    ret = out.str();
    return ret;
}


// struct: SGmplsTest compare-functions due to union existance...
// Found Struct->settings.... 0
// Generated default compare implementation for struct: SGmplsTest
bool operator<(SGmplsTest lhs, SGmplsTest rhs) {
    if (lhs.type       < rhs.type)       return true;
    if (lhs.type       > rhs.type)       return false;
    return false;
}
bool operator<=(SGmplsTest lhs, SGmplsTest rhs) {
    if ((lhs < rhs) || (lhs == rhs)){
        return true;
    } else {
        return false;
    }
}
bool operator>(SGmplsTest lhs, SGmplsTest rhs) {
    return !(lhs <= rhs);
}
bool operator>=(SGmplsTest lhs, SGmplsTest rhs) {
    return !(lhs < rhs);
}
bool operator==(SGmplsTest lhs, SGmplsTest rhs){
    if (lhs.type       != rhs.type)       return false;
    return true;
}
bool operator!=(SGmplsTest lhs, SGmplsTest rhs) {
    return !(lhs == rhs);
}


// Generated toJsonString / fromJsonString implementation for struct: SGmplsTest
std::string toJsonString(SGmplsTest *input) {
  jsonxx::Object jsono;
  jsono << "type" << (unsigned int)input->type;
  return jsono.json();
}


int32_t fromJson(SGmplsTest *output, std::string jsondata) {
  jsonxx::Object json;
  if(!json.parse(jsondata))
  {
    return -2048;
  }
  if(json.has<jsonxx::Number>("type"))
  {
    output->type = (unsigned int)json.get<jsonxx::Number>("type");
  }
  return 0;
}
#endif // ___cplusplus


#endif // __IMPLEMENTATION_PAIR_HPP__

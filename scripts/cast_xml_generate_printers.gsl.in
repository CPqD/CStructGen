.- function resolve_by_name(datanode,name)
.-     my.type_f = my.datanode->FundamentalType(name = my.name)?
.-     my.type_t = my.datanode->Typedef        (name = my.name)?
.-     my.type_e = my.datanode->Enumeration    (name = my.name)?
.-     my.type_s = my.datanode->Struct         (name = my.name)?
.-     if    defined(my.type_f) 
.-       return my.type_f
.-     elsif defined(my.type_t) 
.-       return my.type_t
.-     elsif defined(my.type_e) 
.-       return my.type_e
.-     elsif defined(my.type_s) 
.-       return my.type_s
.-     endif
.- endfunction
.
.
.function container_class_functions_header(class_object)
. if name(my.class_object) <> 'Class'
.   abort "container_class_functions_header - must pass Class-element to generate!"
. endif
>// Generated toJsonString / fromJsonString definition for container-classcomplex-typedef: $(my.e.name:)
>// Internal helper function for $(my.class_object.base_typedef_name:)
>int32_t fromJson($(my.class_object.base_typedef_name:) *output, std::string jsondata) {
>}
>
>
>std::string toJsonString($(my.class_object.base_typedef_name:) *input) {
>}
>
>
.endfunction
.
.
.function header(gentype,original_file)
>/* 
>---- WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING  ----
>---- ANY MANUAL CHANGES IN THIS FILE WILL DISAPPEAR IF YOU REGENERATE ----
>--------------------------------------------------------------------------
> This file has been generated by http://github.com/fnchooft/CStructGen
>--------------------------------------------------------------------------
> Package: @PACKAGE_NAME@
> Version: @PACKAGE_VERSION@
> Sha1sum: $(string.replace(sha1value, "\n|"):)
>--------------------------------------------------------------------------
> Make sure to update the originating $(my.original_file:)-file
>--------------------------------------------------------------------------
>---- WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING  ----
>---- ANY MANUAL CHANGES IN THIS FILE WILL DISAPPEAR IF YOU REGENERATE ----
>*/
.  if (my.gentype = 'definition')
>#ifndef __$(my.GENTYPE:C)_$(my.ORIGINAL_FILE:C)__
>#define __$(my.GENTYPE:C)_$(my.ORIGINAL_FILE:C)__
>
>
>#include "$(my.original_file:)"
>
>
>#ifdef __cplusplus
>
>
>// C++ overloads, methods, and so on
>#include <map>
>#include <string>
>#include <iostream>
>#include <utility>
>#include <sstream>
>#include <stdint.h>
>
>
.  else
>#ifndef __$(my.GENTYPE:C)_$(my.ORIGINAL_FILE:C)__
>#define __$(my.GENTYPE:C)_$(my.ORIGINAL_FILE:C)__
>
>
>#ifdef __cplusplus
>
>
.output_file = file.basename(my.original_file)
.output_file += ".generated.h"
>#include "$(output_file:)"
>#include <stdio.h>
>#include <string.h>
>#include "jsonxx.h"
.  endif
.endfunction
.
.function footer(gentype,original_file)
>#endif // ___cplusplus
>
>
>#endif // __$(my.GENTYPE:C)_$(my.ORIGINAL_FILE:C)__
.endfunction
.
.
.function struct_stream_map_functions(gentype,class,root)
.  if name(my.class) = 'Struct'
.    ftype = my.class->Union?
.    if defined(ftype)
.      struct_settings = root->settings->Struct(name = my.class.name)?
.      if !defined(struct_settings)
.        abort "Failed to load settings for union-field in structure $(my.class.name:)"
.      endif
.    endif
   if (my.gentype = 'definition')
>// Generated stream-operators for: $(my.class.name:)
>std::ostream & operator<<(std::ostream & out, const $(my.class.name:) & $(my.class.name:c));
>std::string toString(const $(my.class.name:) & $(my.class.name:c));
.  else 
>
>// Generated default printers for struct: $(my.class.name:)
>std::ostream & operator<<(std::ostream & out, const $(my.class.name:) & $(my.class.name:c)) {
.  for my.class.Field as f
.    typeobject = f->$(f.resolved_type?)(id?'' = f.type)?

.    union_field = struct_settings->Union(field = f.name)?
.    if defined(union_field)
>    // $(f.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
.[gsl].shuffle = 1
>    if($(my.class.name:c).$(union_field.type:) == $(c.token:)) {
>      out << "$(f.name:).$(c.union_member:):" << " "  << $(my.class.name:c).$(f.name:).$(c.union_member:) << "$(last()?? '' ? ', ')"; 
>    }
.[gsl].shuffle = 2
.      endfor
.    elsif typeobject.container?'not-vector' = 'vector' | typeobject.container?'not-list' = 'list' | typeobject.container?'not-set' = 'set'
>    out << "$(f.name:):" << " [ ";
.    value_type = typeobject->Typedef(name = 'value_type')
.-   // value_type(id): $(value_type.id) value_type(generator_type): $(value_type.generator_type?'not-set':)
>    for (std::$(typeobject.container:)<$(value_type.generator_type:) >::const_iterator it=$(my.class.name:c).$(f.name:).begin(); it != $(my.class.name:c).$(f.name:).end(); ++it)
>    {
>      out << *it;
>      if(it != $(my.class.name:c).$(f.name:).end())
>        out << ",";
>    }
>    out << " ] " << "$(last()?? '' ? ', ')";
.    elsif typeobject.container?'not-map' = 'map'
.-   // MAP-IMPLEMENTATION.. typeobject.id: $(typeobject.id) $(typeobject.container?'really-a-map???')
.    key_type    = typeobject->Typedef(name = 'key_type')
.    mapped_type = typeobject->Typedef(name = 'mapped_type')
>    out << "$(f.name:):" << " [ ";
.-   // key-type: $(key_type.generator_type?'unknown') key_type.id: $(key_type.id)
.-   // map-type: $(mapped_type.generator_type?'unknown') mapped_type.id: $(mapped_type.id)
>    for (
>         std::$(typeobject.container:)<$(key_type.generator_type:),$(mapped_type.generator_type:) >::const_iterator it=$(my.class.name:c).$(f.name:).begin();
>         it != $(my.class.name:c).$(f.name:).end(); 
>         ++it
>	     )
>    {
>      out << it->first << ":" << it->second;
>      if(it != $(my.class.name:c).$(f.name:).end())
>        out << ",";
>    }
>    out << " ] " << "$(last()?? '' ? ', ')";
.    elsif f.container?'not-pair' = 'pair'
>    out << "$(f.name:):" << " first[" << $(my.class.name:c).$(f.name:).first << "] ";
>    out                  << " second[" << $(my.class.name:c).$(f.name:).second << "]";
>    out << "$(last()?? '' ? ', ')";
.    else
.[gsl].shuffle = 1
>    out << "$(f.name:):" << " "  << $(my.class.name:c).$(f.name:) << "$(last()?? '' ? ', ')";
.[gsl].shuffle = 2
.    endif
.  endfor
>    return out;
>}
>
>
>std::string toString(const $(my.class.name:) & $(my.class.name:c)) {
>    std::stringstream out;
>    std::string ret = "";
>    out << $(my.class.name:c);
>    ret = out.str();
>    return ret;
>}
>
>
.  endif
.  endif
.endfunction
.
.
.function struct_compare_functions(gentype,class,root)
.  if name(my.class) = 'Struct'
.    ftype = my.class->Union?
.    struct_settings = root->settings->Struct(name = my.class.name)?
.    if defined(ftype)
.      if !defined(struct_settings)
.        abort "Failed to load settings for union-field in structure $(my.class.name:)"
.      endif
.    endif
.  
>// struct: $(my.class.name:) compare-functions due to union existance...
>// Found Struct->settings.... $(defined(struct_settings))
.  if (my.gentype = 'definition')
>// Generated default compare definitions for struct: $(my.class.name:)
>bool operator< ($(my.class.name:) lhs, $(my.class.name:) rhs);
>bool operator<=($(my.class.name:) lhs, $(my.class.name:) rhs);
>bool operator> ($(my.class.name:) lhs, $(my.class.name:) rhs);
>bool operator>=($(my.class.name:) lhs, $(my.class.name:) rhs);
>bool operator==($(my.class.name:) lhs, $(my.class.name:) rhs);
>bool operator!=($(my.class.name:) lhs, $(my.class.name:) rhs);
.   if defined(struct_settings)
.    for struct_settings.CompareFunction as cp
>
>// Generate CompareFunction $(cp.name:)
>// $(cp.desc:)
>struct $(my.class.name:)$(cp.name:) {
>    $(my.class.name:) rhs;
>    explicit $(my.class.name:)$(cp.name:)($(my.class.name:) rhs) : rhs(rhs) { }
>    inline bool operator()(const $(my.class.name:) & lhs) const
>    {
.[gsl].shuffle = 1
.  for my.class.Field as a
.    is_key = cp->KeyField(name = a.name)?
.    if !defined(is_key)
.      next
.    endif
.    sub_key_variable = ''
.    if defined(is_key->SubKeyField)
.      sub_key_variable = '.' + is_key->SubKeyField.name
.    endif
.    field_to_compare = "$(a.name:)$(sub_key_variable:)"
.    union_field = struct_settings->Union(field = a.name)?
.    if defined(union_field)
>    // $(a.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
>    if(lhs.$(union_field.type:) == $(c.token:)) {
>      if (lhs.$(a.name:).$(c.union_member:) != rhs.$(a.name:).$(c.union_member:)) return false;
>    }
.      endfor
.    else
.      if a.resolved_type?'unresolved-type' = 'ArrayType'
.        at_type = a->ArrayType?
>    // Iterate over ArrayType and check for $(at_type.min)..$(at_type.max) $(at_type.parent_value_type)-field
>    for(int af = $(at_type.min); af <= $(at_type.max); af++)
>    {
>      if (lhs.$(a.name:)[af] != rhs.$(a.name:)[af]) return false;
>    }
.      else
.        typeobject = a->$(a.resolved_type?)(id?'' = a.type)?
.        if typeobject.parent_value_type?'ns' = 'char'
.-        if a.resolved_type?'unresolved-type' = 'PointerType'
>    if (lhs.$(field_to_compare:) == NULL && rhs.$(field_to_compare:) != NULL) return false;
>    if (lhs.$(field_to_compare:) != NULL && rhs.$(field_to_compare:) == NULL) return false;
>    if (strcmp(lhs.$(field_to_compare:),lhs.$(field_to_compare:)) != 0) return false;
.        else
>    if (lhs.$(field_to_compare:) != rhs.$(field_to_compare:)) return false;
.        endif
.      endif
.    endif
.  endfor
.[gsl].shuffle = 2
>    return true;
>    }
>};
>
>
.    endfor
.   endif # only if we have struct_settings....
.  else
>// Generated default compare implementation for struct: $(my.class.name:)
>bool operator<($(my.class.name:) lhs, $(my.class.name:) rhs) {
.[gsl].shuffle = 1
.-----------------------------------------------------------------------------
.- Construct the c-struct-initstring = { .field = default_value, .... }
.-----------------------------------------------------------------------------
.  my.class.c_struct_init = " = {"
.-----------------------------------------------------------------------------
.  for my.class.Field as a
.    union_field = struct_settings->Union(field = a.name)?
.    if defined(union_field)
>    // $(a.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
>    if(lhs.$(union_field.type:) == $(c.token:)) {
>      if (lhs.$(a.name:).$(c.union_member:) < rhs.$(a.name:).$(c.union_member:)) return true;
>      if (lhs.$(a.name:).$(c.union_member:) > rhs.$(a.name:).$(c.union_member:)) return false;
>    }
.      endfor
.    else
.      typeobject = a->$(a.resolved_type?)(id?'' = a.type)?
.- >    // $(a.name?'no-name') resolved_type: $(a.resolved_type?'resolved-type')
.[gsl].shuffle = 2
.      my.class.c_struct_init += " .$(a.name:) = $(a.default_value?'UNKNOWN')$(last(a)??''?',')"
.[gsl].shuffle = 1
.      if a.resolved_type?'unresolved-type' = 'ArrayType'
.        at_type = a->ArrayType?
>    // Iterate over ArrayType and check for $(at_type.min)..$(at_type.max) $(at_type.parent_value_type)-field
>    for(int af = $(at_type.min); af <= $(at_type.max); af++)
>    {
>      if (lhs.$(a.name:)[af] < rhs.$(a.name:)[af]) return true;
>      if (lhs.$(a.name:)[af] > rhs.$(a.name:)[af]) return false;
>    }
.-      elsif typeobject.parent_value_type?'ns' = 'char'
.      elsif a.resolved_type?'unresolved-type' = 'PointerType'
>    // Resolved type is $(a.resolved_type?'not-set') and points to char...
>    int $(a.name:)_compare = strcmp(lhs.$(a.name:),rhs.$(a.name:));
>    if ($(a.name:)_compare < 0) return true;
>    if ($(a.name:)_compare > 0) return false;
.      else
>    if (lhs.$(a.name:) < rhs.$(a.name:)) return true;
>    if (lhs.$(a.name:) > rhs.$(a.name:)) return false;
.      endif
.    endif
.  endfor
.  my.class.c_struct_init += " }"
.[gsl].shuffle = 2
>    return false;
>}
>bool operator<=($(my.class.name:) lhs, $(my.class.name:) rhs) {
>    if ((lhs < rhs) || (lhs == rhs)){
>        return true;
>    } else {
>        return false;
>    }
>}
>bool operator>($(my.class.name:) lhs, $(my.class.name:) rhs) {
>    return !(lhs <= rhs);
>}
>bool operator>=($(my.class.name:) lhs, $(my.class.name:) rhs) {
>    return !(lhs < rhs);
>}
>bool operator==($(my.class.name:) lhs, $(my.class.name:) rhs){
.[gsl].shuffle = 1
.  for my.class.Field as a
.    union_field = struct_settings->Union(field = a.name)?
.    if defined(union_field)
>    // $(a.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
>    if(lhs.$(union_field.type:) == $(c.token:)) {
>      if (lhs.$(a.name:).$(c.union_member:) != rhs.$(a.name:).$(c.union_member:)) return false;
>    }
.      endfor
.    else
.      if a.resolved_type?'unresolved-type' = 'ArrayType'
.        at_type = a->ArrayType?
>    // Iterate over ArrayType and check for $(at_type.min)..$(at_type.max) $(at_type.parent_value_type)-field
>    for(int af = $(at_type.min); af <= $(at_type.max); af++)
>    {
>      if (lhs.$(a.name:)[af] != rhs.$(a.name:)[af]) return false;
>    }
.      else
.        typeobject = a->$(a.resolved_type?)(id?'' = a.type)?
.        if typeobject.parent_value_type?'ns' = 'char'
>    // Resolved type is $(a.resolved_type?'not-set') and points to char...
>    if (lhs.$(a.name:) == NULL && rhs.$(a.name:) != NULL) return false;
>    if (lhs.$(a.name:) != NULL && rhs.$(a.name:) == NULL) return false;
>    if (strcmp(lhs.$(a.name:),lhs.$(a.name:)) != 0) return false;
.        else
>    if (lhs.$(a.name:) != rhs.$(a.name:)) return false;
.        endif
.      endif
.    endif
.  endfor
.[gsl].shuffle = 2
>    return true;
>}
>bool operator!=($(my.class.name:) lhs, $(my.class.name:) rhs) {
>    return !(lhs == rhs);
>}
>
>
.  endif
.  endif
.endfunction
.
.
.function render_fundamental_to_json(scope,json_object,field_object,type_object,input_variable)
.  if !defined(my.type_object.json_type)
.    abort "[$(my.scope)] field $(my.field_object.name?'no-name-set':) type $(name(my.type_object)) in line $(my.type_object.location?'no-location') has no json_type!"
.  endif
.- // scope:$(my.scope:)  object_name:$(name(my.type_object)) json_type:$(my.type_object.json_type) parent_type: $(my.type_object.parent_type?'no-parent-type')
.  if my.type_object.json_type?'Impossible' = 'Object'
.    if my.type_object.generator_type?'unknown' = 'in_addr'  | my.type_object.name = 'in_addr'
.      if my.scope = 'VectorList'
>  $(my.json_object:) << toString($(my.input_variable:));
.      else
>  $(my.json_object:) << "$(my.field_object.name:)" << toString($(my.input_variable:));
.      endif
     else
>  jsonxx::Object $(my.scope:)_$(my.field_object.name:)_object;
.      if    my.scope = 'MapKey'
>  // For the Map-key we need to cast for non-constness.
>  if($(my.scope:)_$(my.field_object.name:)_object.parse(toJsonString(($(my.type_object.generator_type:)*)&$(my.input_variable:))) != 1)
.      else
>  if($(my.scope:)_$(my.field_object.name:)_object.parse(toJsonString(&$(my.input_variable:))) != 1)
.      endif
>    return "BROKEN $(my.field_object.name:)_object";
.      if    my.scope = 'MapKey'
>  $(my.json_object:) << "key" << $(my.scope:)_$(my.field_object.name:)_object;
.      elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << $(my.scope:)_$(my.field_object.name:)_object;
.      else
>  $(my.json_object:) << "$(my.field_object.name:)" << $(my.scope:)_$(my.field_object.name:)_object;
.      endif
.    endif
.  elsif my.type_object.json_type = 'Number' | my.type_object.json_type = 'String'
.    if my.scope = 'Array'
>  $(my.json_object:)          << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapKey'
>  $(my.json_object:) << "key" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'VectorList'
.      if name(my.type_object) = 'Enumeration' | my.type_object.parent_type?'' = 'Enumeration'
>  $(my.json_object:) << $(my.type_object.json_type_cast?'')toString($(my.input_variable:));
.      else
>  $(my.json_object:) << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.      endif
.    elsif name(my.type_object) = 'Enumeration' | my.type_object.parent_type?'' = 'Enumeration'
>  $(my.json_object:) << "$(my.field_object.name:)" << toString($(my.input_variable:));
.    else
>  $(my.json_object:) << "$(my.field_object.name:)" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    endif
.  elsif my.type_object.json_type = 'Boolean'
.    if my.scope = 'Array'
>  $(my.json_object:)          << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapKey'
>  $(my.json_object:) << "key" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'VectorList'
>  $(my.json_object:) << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    else
>  $(my.json_object:) << "$(my.field_object.name:)" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    endif
.  elsif my.type_object.json_type = 'Enumeration' | my.type_object.json_type = 'InAddr' 
.    if my.scope = 'Array'
>  $(my.json_object:) << toString($(my.input_variable:));
.    elsif my.scope = 'MapKey'
>  $(my.json_object:) << "key" << toString($(my.input_variable:));
.    elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << toString($(my.input_variable:));
.    elsif my.scope = 'VectorList'
>  $(my.json_object:) << toString($(my.input_variable:));
.    else
>  $(my.json_object:) << "$(my.field_object.name:)" << toString($(my.input_variable:));
.    endif
.  elsif my.type_object.json_type_cast = '(signed char)'
.    if my.scope = 'Array'
>  $(my.json_object:) << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapKey'
>  $(my.json_object:) << "key" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    elsif my.scope = 'VectorList'
>  $(my.json_object:) << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    else
>  $(my.json_object:) << "$(my.field_object.name:)" << $(my.type_object.json_type_cast?'')$(my.input_variable:);
.    endif
.  else
>  // Else-render_fundamental_to_json-branch...
.    if my.scope = 'Array'
>  $(my.json_object:) << ($(my.type_object.name:))$(my.input_variable:); // Array-else....
.    elsif my.scope = 'MapKey'
>  $(my.json_object:) << "key" << $(my.input_variable:);
.    elsif my.scope = 'MapVal'
>  $(my.json_object:) << "val" << $(my.input_variable:);
.    elsif my.scope = 'VectorList'
>  $(my.json_object:) << $(my.input_variable:); // VectorList-else....
.    else
>  $(my.json_object:) << "$(my.field_object.name:)" << $(my.type_object.json_type_cast?'')$(my.input_variable:); // ??Scope??-else....
.    endif
.  endif
.endfunction
.
.function struct_json_header_functions(class,root)
>// Generated toJsonString / fromJsonString definition for struct: $(my.class.name:)
>std::string toJsonString($(my.class.name:) *input);
>int32_t fromJson($(my.class.name:) *output, std::string jsondata);
.endfunction
.
.
.function struct_json_functions(gentype,class,root)
.  if (my.gentype = 'definition')
.struct_json_header_functions(my.class,my.root)
.  else
.  if name(my.class) = 'Struct'
.    ftype = my.class->Union?
.    if defined(ftype)
.      struct_settings = root->settings->Struct(name = my.class.name)?
.      if !defined(struct_settings)
.        abort "Failed to load settings for union-field in structure $(my.class.name:)"
.      endif
.    endif
>// Generated toJsonString / fromJsonString implementation for struct: $(my.class.name:)
>std::string toJsonString($(my.class.name:) *input) {
.- [gsl].shuffle = 1
>  jsonxx::Object jsono;
.  for my.class.Field as a
.    union_field = struct_settings->Union(field = a.name)?
.    typeobject = a->$(a.resolved_type?)(id?'' = a.type)?
.- >  // $(name(typeobject)?) name: [$(typeobject.name?'no-name')] json_type: $(typeobject.json_type?'not-set') json_type_cast: $(typeobject.json_type_cast?'not-set')
.-   IF the typeobject is not in the field then it was not copied over....
.-    if !defined(typeobject)
.-      typeobject = root->GCC_XML->$(a.resolved_type?)(id?'' = a.type)?
.-    endif
.    if !defined(typeobject)
.      abort "No typeobject?? $(a.name)"
.    endif
.- ------------------------------------union_field defined -------------------------------------------------
.    if defined(union_field)
>  // $(a.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
>  if(input->$(union_field.type:) == $(c.token:)) {
>     jsonxx::Object $(a.name:)_object;
>     if($(a.name:)_object.parse(toJsonString(&input->$(a.name:).$(c.union_member:))) != 1)
>       return "BROKEN_$(a.name:).$(c.union_member:)";
>     jsono << "$(a.name:).$(c.union_member:)" << $(a.name:)_object;
>  }
.      endfor
.- ------------------------------------resolved-type: ArrayType -------------------------------------------------
.    elsif a.resolved_type?'unresolved-type' = 'ArrayType'
.      at_type = a->ArrayType?
.      array_element_type = at_type->$(at_type.parent_type)(id?'' = at_type.type)
>  jsonxx::Array jsona_$(a.name:);
>  // Iterate over ArrayType and check for $(at_type.min)..$(at_type.max) $(at_type.parent_value_type)-field
>  for(int af = $(at_type.min); af <= $(at_type.max); af++)
>  {
.    render_fundamental_to_json("Array","  jsona_$(a.name:)",a,array_element_type,"input->$(a.name:)[af]")
>  }
>  jsono << "$(a.name:)" << jsona_$(a.name:);
.- ------------------------------------resolved-type: Class ----------------------------------------------------
.    elsif a.resolved_type = 'Class'
.      if defined(typeobject.container) # See container-preparations in Struct/Field/Class-type
.        if typeobject.container?'not-vector' = 'vector' | typeobject.container?'not-list' = 'list' | typeobject.container?'not-set' = 'set'
.-       ------------------------------------ vector | list ---------------------------------------
.- // $(a.name:) is of type: $(name(typeobject?'no-typeobject')) trying to resolve type $(typeobject.parent_type?'no-typeobject':)
.        value_type = typeobject->Typedef(name = 'value_type')
.- // ABCDE:FGHIJ: Found $(name(value_type)) - value_type id: $(value_type.id)
>  jsonxx::Array jsona_$(a.name:);
>  for (std::$(typeobject.container:)<$(value_type.generator_type:) >::iterator it=input->$(a.name:).begin(); it != input->$(a.name:).end(); ++it)
>  {
.    render_fundamental_to_json("VectorList","  jsona_$(a.name:)",a,value_type,"*it")
>  }
>  jsono << "$(a.name:)" << jsona_$(a.name:);
.        elsif typeobject.container?'not-map' = 'map'
.-       ------------------------------------ map -------------------------------------------------
>  jsonxx::Array jsonm_$(a.name:);
.  key_type    = typeobject->Typedef(name = 'key_type')
.  mapped_type = typeobject->Typedef(name = 'mapped_type')
.- >  // key-type: $(key_type.generator_type?'unknown') key_type.id: $(key_type.id)
.- >  // map-type: $(mapped_type.generator_type?'unknown') mapped_type.id: $(mapped_type.id)
>  for (
>       std::$(typeobject.container:)<$(key_type.generator_type:),$(mapped_type.generator_type:) >::iterator it=input->$(a.name:).begin();
>       it != input->$(a.name:).end(); 
>       ++it
>      )
>  {
>    jsonxx::Object map_entry;
.    render_fundamental_to_json("MapKey","map_entry",a   ,key_type,"it->first")
.    render_fundamental_to_json("MapVal","map_entry",a,mapped_type,"it->second")
>    jsonm_$(a.name:) << map_entry;
>  }
>  jsono << "$(a.name:)" << jsonm_$(a.name:);
.        else
.-       ------------------------------------ ??? -------------------------------------------------
>  // generator::557: Not defined for container_type: $(a.container_type?'unknown')
.        endif
.      else
.        render_fundamental_to_json("$(a.name:)","jsono",a,typeobject,"input->$(a.name:)")
.      endif
.- ------------------------------------container: pair -----------------------------------------------------------
.    elsif a.resolved_type = 'Struct' & a.container?'not-pair' = 'pair'
>  // Pair handling Field->Struct->Field.first && Field.second
>  jsonxx::Object $(a.name:)_pair_object;
.        pair_struct = a->Struct(id = a.type)
.        first_field = pair_struct->Field(name = "first")
.        first_type  = first_field->$(first_field.resolved_type)
.        second_field = pair_struct->Field(name = "second")
.        second_type  = second_field->$(second_field.resolved_type)
.        render_fundamental_to_json("$(a.name:)","$(a.name:)_pair_object",first_field,first_type,"input->$(a.name:).first")
.        render_fundamental_to_json("$(a.name:)","$(a.name:)_pair_object",second_field,second_type,"input->$(a.name:).second")
>  jsono << "$(a.name:)" << $(a.name:)_pair_object;
.- ------------------------------------resolved-type: Class ----------------------------------------------------
.    else
.      render_fundamental_to_json("$(a.name:)","jsono",a,typeobject,"input->$(a.name:)")
.    endif
.- ----------------------------------------------------------------------------------------
.  endfor
.- [gsl].shuffle = 2
>  return jsono.json();
>}
>
>
>int32_t fromJson($(my.class.name:) *output, std::string jsondata) {
>  jsonxx::Object json;
>  if(!json.parse(jsondata))
>  {
>    return -2048;
>  }
.  for my.class.Field as a 
.-   // Return the negative-bitindex $(index(a)) of the $(a.name:)-field on error
.    union_field = struct_settings->Union(field = a.name)?
.    if defined(union_field)
>    // $(a.name:) --> based on the value of $(union_field.type:) part of union $(union_field.field)
.      for union_field.Choice as c
>  if(output->$(union_field.type:) == $(c.token:)) {
>    if(json.has<jsonxx::Object>("$(a.name:).$(c.union_member:)"))
>    {
>      if(fromJson(&output->$(a.name:).$(c.union_member:), json.get<jsonxx::Object>("$(a.name:).$(c.union_member:)").json()) != 0)
>      {
>        return -$(index(a));
>      }
>    }
>  }
.      endfor
.- For all non-union types....
.  else
.    typeobject = a->$(a.resolved_type)(id?'' = a.type)?
.- // [$(typeobject.name?'oopsie')] -> typeOf: $(name(typeobject)) -> parent_type $(typeobject.parent_type?'unknown')
.  if typeobject.container?'not-vector' = 'vector' | typeobject.container?'not-list' = 'list' | typeobject.container?'not-set' = 'set'
.- // $(typeobject.container)-container implementation...
>  if(json.has<jsonxx::Array>("$(a.name:)"))
>  {
>    jsonxx::Array $(a.name:)_array = json.get<jsonxx::Array>("$(a.name:)");
>    for(int af = 0; af < $(a.name:)_array.size(); af++)
>    {
.      value_type = typeobject->Typedef(name = 'value_type')
.      if value_type.generator_type = 'in_addr'
.-     ----------------------------------------------------------------------------------
>      $(value_type.generator_type:) $(a.name:)_af;
>      std::string $(name:c)_str = $(a.name:)_array.get<jsonxx::String>(af);
>      int cc = inet_pton(AF_INET, $(name:c)_str.c_str(), &$(a.name:)_af);
>      if(cc == 0) // Error
>      {
>        return -$(index(a));
>      }
.      elsif a.resolved_type = 'Class'
.-     ----------------------------------------------------------------------------------
>      $(value_type.generator_type:) $(a.name:)_af;
.        if value_type.json_type?'not-Object' = 'Object'
>      if(fromJson(&$(a.name:)_af, $(a.name:)_array.get<jsonxx::Object>(af).json()) != 0)
>      {
>        return -$(index(a));
>      }
.        elsif value_type.parent_type?'not-Enumeration' = 'Enumeration' 
>      // Fraq - enumeration is false/true not 0/1
>      if(fromString($(a.name:)_array.get<jsonxx::String>(af),&$(a.name:)_af) == false)
>      {
>        return -$(index(a));
>      }
.        else
>      $(a.name:)_af = $(value_type.json_type_cast?'':)$(a.name:)_array.get<jsonxx::$(value_type.json_type:)>(af);
.        endif
.      endif
.      if typeobject.container = 'set'
>      output->$(a.name:).insert($(a.name:)_af);
.      else
>      output->$(a.name:).push_back($(a.name:)_af);
.      endif
>    }
>  }
.  elsif a.container?'not-pair' = 'pair'
>  // Pair-implementation deserializes into an Object.
>  if(json.has<jsonxx::Object>("$(a.name:)"))
>  {
>    jsonxx::Object $(a.name:)_object = json.get<jsonxx::Object>("$(a.name:)");
.    pair_struct = a->Struct(id = a.type)
.    first_field = pair_struct->Field(name = "first")
.    first_type  = first_field->$(first_field.resolved_type)
.    second_field = pair_struct->Field(name = "second")
.    second_type  = second_field->$(second_field.resolved_type)
>
>    // First  is of type $(first_type.name:)  $(name(first_type):)  json_type: $(first_type.json_type:)
>    // Second is of type $(second_type.name:) $(name(second_type):) json_type: $(second_type.json_type:)
>    $(first_type.name:) $(a.name:)_first = $(a.name:)_object.get<jsonxx::$(first_type.json_type:)>("first");
>    $(second_type.name:) $(a.name:)_second;
>    if(fromJson(&$(a.name:)_second, $(a.name:)_object.get<jsonxx::$(second_type.json_type:)>("second").json()) != 0)
>    {
>      return -$(index(a));
>    }
>    output->$(a.name:) = std::make_pair($(a.name:)_first,$(a.name:)_second);
>  }
.  elsif typeobject.container?'not-map' = 'map'
.    key_type    = typeobject->Typedef(name = 'key_type')
.    mapped_type = typeobject->Typedef(name = 'mapped_type')
.- // key-type: $(key_type.generator_type?'unknown') key_type.id: $(key_type.id)
.- // map-type: $(mapped_type.generator_type?'unknown') mapped_type.id: $(mapped_type.id)
>  std::cout << "fromJson: $(a.name:)...." << std::endl;
>  if(json.has<jsonxx::Array>("$(a.name:)"))
>  {
>    jsonxx::Array $(a.name:)_map_array = json.get<jsonxx::Array>("$(a.name:)");
>    for(int af = 0; af < $(a.name:)_map_array.size(); af++)
>    {
>      jsonxx::Object $(a.name:)_map_array_entry = $(a.name:)_map_array.get<jsonxx::Object>(af);
.-     ------------ read key-attribute ---------------------------------------------------------
>      $(key_type.generator_type:) map_key;
>      $(mapped_type.generator_type:) map_val;
>      if($(a.name:)_map_array_entry.has<jsonxx::$(key_type.json_type:)>("key"))
>      {
.      if key_type.json_type = 'Object'
>        if(fromJson(&map_key, $(a.name:)_map_array_entry.get<jsonxx::$(key_type.json_type:)>("key").json()) != 0)
>        {
>          return -$(index(a));
>        }
.      else
>        map_key = $(a.name:)_map_array_entry.get<jsonxx::$(key_type.json_type:)>("key");
.      endif
>      }
.-     ------------ read val-attribute ---------------------------------------------------------
>      if($(a.name:)_map_array_entry.has<jsonxx::$(mapped_type.json_type:)>("val"))
>      {
.      if mapped_type.json_type = 'Object'
>        if(fromJson(&map_val, $(a.name:)_map_array_entry.get<jsonxx::$(mapped_type.json_type:)>("val").json()) != 0)
>        {
>          return -$(index(a));
>        }
.      else
>        map_val = $(a.name:)_map_array_entry.get<jsonxx::$(mapped_type.json_type:)>("val");
.      endif
>      }
>      output->$(a.name:)[map_key] = map_val;
>    }
>  }
.  elsif typeobject.name?'unknown' = 'in_addr'
>  if(json.has<jsonxx::String>("$(a.name:)"))
>  {
>    std::string $(name:c)_str = json.get<jsonxx::String>("$(a.name:)");
>    int cc = inet_pton(AF_INET, $(name:c)_str.c_str(), &output->$(a.name:));
>    if(cc == 0) // Error
>      return -$(index(a));
>  }
.  elsif name(typeobject) = 'ArrayType'
>  if(json.has<jsonxx::Array>("$(a.name:)"))
>  {
.    at_type = a->ArrayType?
>    // Iterate over ArrayType and check for $(at_type.min)..$(at_type.max) $(at_type.parent_value_type)-field
>    if(json.get<jsonxx::Array>("$(a.name:)").size() != $(at_type.max)+1)
>      return  -$(index(a));
>    for(int af = $(at_type.min); af <= $(at_type.max); af++)
>    {
>      output->$(a.name:)[af] = json.get<jsonxx::Array>("$(a.name:)").get<jsonxx::Number>(af);
>    }
>  }
.  elsif typeobject.parent_type?'unknown' = 'Struct'
>  if(json.has<jsonxx::Object>("$(a.name:)"))
>  {
>    if(fromJson(&output->$(a.name:), json.get<jsonxx::Object>("$(a.name:)").json()) != 0)
>    {
>      return -$(index(a));
>    }
>  }
.  elsif name(typeobject)?'unknown' = 'Enumeration' | typeobject.parent_type?'' = 'Enumeration'
>  if(json.has<jsonxx::String>("$(a.name:)"))
>  {
>    if(fromString(json.get<jsonxx::String>("$(a.name:)"),&output->$(a.name:)) == false)
>    {
>      return -$(index(a));
>    }
>  }
.  elsif typeobject.parent_value_type?'not-char' = 'char'
>  if(json.has<jsonxx::String>("$(a.name:)"))
>  {
>    output->$(a.name:) = strdup(json.get<jsonxx::String>("$(a.name:)").c_str());
>  }
.  else
>  if(json.has<jsonxx::$(typeobject.json_type:)>("$(a.name:)"))
>  {
>    output->$(a.name:) = $(typeobject.json_type_cast?'':)json.get<jsonxx::$(typeobject.json_type:)>("$(a.name:)");
>  }
.  endif
.  endif
.  endfor
>  return 0;
>}
.  endif
.  endif
.endfunction
.
.
.function enum_str_from_to_functions(gentype,type)
.  my.typename = name(my.type)
.  if my.typename = 'Enumeration'
.  if my.gentype = 'definition'
>// Generated default toString,fromString,stream definitions for enumeration: $(my.type.name:)
>std::string toString($(my.type.name:) enumval, int32_t shortname = 0);
>bool fromString(std::string stringvalue, $(my.type.name:Pascal) *enum_ptr);
>std::ostream & operator<<(std::ostream & out, const $(my.type.name:Pascal) $(my.type.name:c));
.  else
.  my.type.prefix_count = 100
.  my.type.prefix_string = ''
.  my.type.prefix_string_first = my.type->EnumValue.name
.  for my.type.EnumValue as ev
.    ev.short_name = ev.name
.    ev.parts = string.cntch(ev.name,'_')
.    if(my.type.prefix_count >= ev.parts)
.      my.type.prefix_count = ev.parts
.    endif
.  endfor
.  while my.type.prefix_count > 0
.    my.type.prefix              = string.prefix(my.type.prefix_string_first,'_')+'_'
.    my.type.prefix_string_first = string.defix(my.type.prefix_string_first,my.type.prefix)
.    my.type.prefix_string += my.type.prefix
.    for my.type.EnumValue as ev
--      $(ev.name) prefixed -> $(string.prefixed(ev.name,my.type.prefix_string)) with [$(my.type.prefix_string)]
.       new_name = string.defix(ev.name,my.type.prefix_string)
.       if string.length(new_name) > 0
.         ev.short_name = new_name
.       else
.         my.type.prefix_count = 0
.       endif
.    endfor
.    my.type.prefix_count  -= 1 
.  endwhile
>//Generated default toString,fromString,stream implementations for enumeration: $(my.type.name:)
>std::string toString($(my.type.name:) enumval, int32_t shortname)
>{
.[gsl].shuffle = 1
.  for my.type.EnumValue as ev
>  if(enumval == $(ev.name:)){
>    return shortname == 0 ? "$(ev.name:)" : "$(ev.short_name)";
>  }
.  endfor
.[gsl].shuffle = 2
>  return shortname == 0 ? "??????" : "???";
>} // toString for $(my.type.name:)
>
>
>bool fromString(std::string svalue, $(my.type.name:Pascal) *enum_ptr)
>{
.  default_enum = my.type->EnumValue
.[gsl].shuffle = 1
.  for my.type.EnumValue as ev
>  if(svalue == "$(ev.name:)" || svalue == "$(ev.short_name)") {
>    *enum_ptr = $(ev.name:); return true;
>  }
.  endfor
.[gsl].shuffle = 2
>  return false;
>} // $(my.type.name:Pascal)_fromString
>
>
>std::ostream & operator<<(std::ostream & out, const $(my.type.name:Pascal) $(my.type.name:c))
>{
>  out << toString($(my.type.name:c));
>  return out;
>} // $(my.type.name:Pascal) stream-operator
>
>
.  endif
.  endif
.endfunction
.
.
.function test_structure(structure)
.namespaces(e,"open")
>TEST($(my.structure.name:), compareAB){
.if switches.cstandard?'C99' = 'C99'
>  $(my.structure.name:) a$(my.structure.c_struct_init?' = {}':);
>  $(my.structure.name:) b$(my.structure.c_struct_init?' = {}':);
.else
>  $(my.structure.name:) a = $(my.structure.name:)();
>  $(my.structure.name:) b = $(my.structure.name:)();
.endif
>  EXPECT_EQ(a,b);
.if switches.cstandard?'C99' = 'C99'
>  $(my.structure.name:) c$(my.structure.c_struct_init?' = {}':);
.else
>  $(my.structure.name:) c = $(my.structure.name:)();
.endif
>  std::cout << "JSON-b: " << toJsonString(&b) << std::endl;
>  EXPECT_EQ(0,fromJson(&c, toJsonString(&b)));
>  std::cout << "JSON-c: " << toJsonString(&c) << std::endl;
>  EXPECT_EQ(c,b);
>}
.namespaces(e,"close")
>
.endfunction
.
.
.function namespaces(element,type)
.  my.context = my.element.context?""
.  my.namespace_object = root->GCC_XML->Namespace(id = my.context)?
.  if my.type = "open" & my.context <> "_1"
.- >//namespace->type -> $(my.type)
.    if defined(my.namespace_object) 
.- >//namespace->context -> has namespace_object $(my.namespace_object.name)
.      namespaces(my.namespace_object,my.type)
>namespace $(my.namespace_object.name:) {
.    endif
.  endif
.  if my.type = "close" & my.context <> "_1"
.    if defined(my.namespace_object) 
>} // End of namespace $(my.namespace_object.name:)
>
>
.      namespaces(my.namespace_object,my.type)
.    endif
.  endif
.endfunction
.
.
.- -----------------------------------------------------------------------------
.-  START OF SCRIPTS
.- -----------------------------------------------------------------------------
.template 0
.  echo "Read definition settings for file: $(filename:)...."
.  settings_file="$(filename:).settings.xml"
.  if !file.exists (settings_file)
.    echo "  WARNING: File $(settings_file:) Could not be found in PATH... - IGNORING"
.  else
.    echo "  LOADING: File $(settings_file:)..."
.    settings = XML.load_file(settings_file)
.    echo "    Loaded $(count(settings.))-Settings..."
.    copy settings to root before GCC_XML
.  endif
.endtemplate
.- CLEAN UP Structures - moving internal components inside to make sure where
.- handle internal structs (inside unions) differently.
.- -----------------------------------------------------------------------------
.c_standards = "C99|C11|C14"
.c_standard  = "C99"
.if defined(switches.cstandard)
.  c_standard = switches.cstandard
.  if !regexp.match("$(C_STANDARDS:)","$(C_STANDARD:)")
.    abort "cstandards supported are $(c_standards:) - Passed standard: $(c_standard:) is not supported!"
.  endif
.else
.  echo "Defaulting to c-standard:  $(c_standard:)"
.endif
.- -----------------------------------------------------------------------------
.echo "  Cleaning up definition file..."
.- -----------------------------------------------------------------------------
.---- http://en.cppreference.com/w/cpp/language/types -- will factor this out in a seperate-file
.- -------------------------------------------------------------------------------------------
.new TypeMapping 
.  TypeMapping.type = 'unsigned long'
.  TypeMapping.new_type = 'uint64_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned long)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'long unsigned int'
.  TypeMapping.new_type = 'uint64_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned long)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'in_addr'
.  TypeMapping.new_type = 'in_addr'
.  TypeMapping.default  = '{ 0 }'
.  TypeMapping.jsonxx_type  = 'String'
.  TypeMapping.jsonxx_type_cast = '(std::string)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'float'
.  TypeMapping.new_type = 'float'
.  TypeMapping.default  = '0.0f'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(float)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'double'
.  TypeMapping.new_type = 'double'
.  TypeMapping.default  = '0.0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(double)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'long'
.  TypeMapping.new_type = 'int64_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(long long)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'long int'
.  TypeMapping.new_type = 'int64_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(long long)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'unsigned int'
.  TypeMapping.new_type = 'uint32_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'int'
.  TypeMapping.new_type = 'int32_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'unsigned short'
.  TypeMapping.new_type = 'uint16_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'short unsigned int'
.  TypeMapping.new_type = 'uint16_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'short int'
.  TypeMapping.new_type = 'int16_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(signed int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'short'
.  TypeMapping.new_type = 'int16_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(signed int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'unsigned char'
.  TypeMapping.new_type = 'uint8_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'signed char'
.  TypeMapping.new_type = 'int8_t'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(signed int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'char'
.  TypeMapping.new_type = 'char'
.  TypeMapping.default  = '0'
.  TypeMapping.jsonxx_type  = 'Number'
.  TypeMapping.jsonxx_type_cast = '(unsigned int)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'bool'
.  TypeMapping.new_type = 'bool'
.  TypeMapping.default  = 'false'
.  TypeMapping.jsonxx_type  = 'Boolean'
.  TypeMapping.jsonxx_type_cast = '(bool)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'std::basic_string<char>'
.  TypeMapping.new_type = 'std::string'
.  TypeMapping.default  = '""'
.  TypeMapping.jsonxx_type  = 'String'
.  TypeMapping.jsonxx_type_cast = '(std::string)'
.endnew
.new TypeMapping 
.  TypeMapping.type = 'std::string'
.  TypeMapping.new_type = 'string'
.  TypeMapping.default  = '""'
.  TypeMapping.jsonxx_type  = 'String'
.  TypeMapping.jsonxx_type_cast = '(std::string)'
.endnew
.- -------------------------------------------------------------------------------------------
.for Function as f
. delete f
.endfor
.for Method as m
. delete m
.endfor
.for OperatorMethod as m
. delete m
.endfor
.for OperatorFunction as o
. delete o
.endfor
.for Constructor as c
. delete c
.endfor
.for Destructor as d
. delete d
.endfor
.- -------------------------------------------------------------------------------------------
.for . as element where defined(id)
.  new root->GCC_XML.Id2Type
.   Id2Type.eid    = element.id
.   Id2Type.ename  = name(element)
.  endnew
.endfor
.- -------------------------------------------------------------------------------------------
.for Class as c
.  if    string.prefixed(c.name?'no-t-name',"vector<")
.    c.container = 'vector'
.  elsif string.prefixed(c.name?'no-t-name',"list<")
.    c.container = 'list'
.  elsif string.prefixed(c.name?'no-t-name',"map<")
.    c.container = 'map'
.  elsif string.prefixed(c.name?'no-t-name',"set<")
.    c.container = 'set'
.  endif
.endfor
.echo "  Handling Enumerations..."
.- -------------------------------------------------------------------------------------------
.for Enumeration as e
.  e.default_value = e->EnumValue.name
.  e.json_type = 'String'
.  e.from_json_function = 'toString'
.  e.json_type_cast = '(std::string)'
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling FundamentalTypes..."
.for FundamentalType as ft
.  type_mapping_object = root->GCC_XML->TypeMapping(type = ft.name)?
.  if defined(type_mapping_object)
.    ft.json_type_cast = type_mapping_object.jsonxx_type_cast
.    ft.json_type      = type_mapping_object.jsonxx_type
.    ft.default_value  = type_mapping_object.default
.  else
.    echo "    Could not resolve FundamentalType $(ft.name)..."
.  endif
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling PointerTypes..."
.for PointerType as pt
.  pttype = root->GCC_XML->Id2Type(eid = pt.type)?
.  if defined(pttype)
.    pointed_type = root->GCC_XML->$(pttype.ename)(id = pt.type?'')?
.    if defined(pointed_type) & pointed_type.name?'ns' = 'char'
.      echo "    Special handling for pointer-to-char handling as std::string..."
.      pt.json_type_cast = "(std::string)"
.      pt.parent_value_type = "char" 
.      pt.json_type = "String"
.      pt.default_value = 'strdup("NADA")'
.      copy pointed_type to pt
.    endif   
.  endif
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling Typedefs..."
.for Typedef as t
.  tt = root->GCC_XML->Id2Type(eid = t.type)?
.  if defined(tt)
.    t.parent_type = tt.ename
.    type_mapping_object = root->GCC_XML->TypeMapping(new_type = t.name)?
.-   If we did not explicitly have a type definition look up the fundamental-type
.    if !defined(type_mapping_object)
.      fundamental_type = root->GCC_XML->FundamentalType(id = t.type?'')?
.      if defined(fundamental_type)
.-        echo "$(t.name:): Setting type_mapping_object FundamentalType"
.        type_mapping_object = root->GCC_XML->TypeMapping(type = fundamental_type.name)?
.      endif
.    endif
.    if defined(type_mapping_object)
.-      echo "$(t.name:): TypeMapping found: $(type_mapping_object.type:) -> $(type_mapping_object.new_type)"
.      t.generator_type  = type_mapping_object.new_type
.      t.json_type_cast  = type_mapping_object.jsonxx_type_cast
.      t.json_type       = type_mapping_object.jsonxx_type
.      t.default_value   = type_mapping_object.default
.    elsif t.parent_type = 'Enumeration'
.      et = root->GCC_XML->Enumeration(id = t.type)
.      t.generator_type     = et.name
.      t.json_type_cast     = et.json_type_cast?
.      t.json_type          = et.json_type?
.      t.default_value      = et.default_value?
.      t.from_json_function = et.from_json_function?
.    elsif t.parent_type = 'Struct'
.      st = root->GCC_XML->Struct(id = t.type)
.      if string.prefixed(st.name,"basic_string<char")
.        t.generator_type = 'std::string'
.        t.json_type      = 'String'
.      elsif string.prefixed(st.name,"pair") | string.prefixed(st.name,"vector") | string.prefixed(st.name,"list") | string.prefixed(st.name,"map") | string.prefixed(st.name,"set")
.        t.generator_type = 'std::' + st.name
.        t.json_type      = 'Container'
.      elsif st.name = 'in_addr'
.        t.generator_type = st.name
.        t.json_type      = 'InAddr'
.      else
.        t.generator_type = st.name
.        t.json_type      = 'Object'
.      endif
.      t.default_value  = st.default_value?
.    elsif t.parent_type = 'Class'
.      st = root->GCC_XML->Class(id = t.type)
.      if string.prefixed(st.name,"basic_string<char")
.        t.generator_type = 'std::string'
.        t.json_type      = 'String'
.      elsif string.prefixed(st.name,"pair") | string.prefixed(st.name,"vector") | string.prefixed(st.name,"list") | string.prefixed(st.name,"map") | string.prefixed(st.name,"set")
.        t.generator_type = 'std::' + st.name
.        t.json_type      = 'Object'
.      else
.        t.generator_type = st.name
.        t.json_type      = 'Object'
.      endif
.      t.default_value  = st.default_value?
.    else
.-      t.json_type_cast = tt.json_type_cast?
.-      t.json_type      = tt.json_type?
.-      t.default_value  = tt.default_value?
.    endif
.  else
.    echo "Could not find type for Typedef $(t.name:)"
.  endif
.endfor
.- root.save("$(filename:)-1172.xml")
.- -------------------------------------------------------------------------------------------
.echo "  Handling ArrayTypes..."
.for ArrayType as at
.  for root->GCC_XML. as tt where tt.id?'' = at.type
.      copy tt to at
.      at.parent_type = name(tt)
.      at.parent_value_type = tt.name?'Unknown-Parent-Value-Type'
.      if max?0 > min?100
.       at.default_value = '{ '
.       iter = min 
.       while iter <= max 
.          at.default_value += "$(tt.default_value?'0')"
.          iter += 1
.          if(iter <= max)
.          at.default_value += ','
.          endif
.        endwhile
.        at.default_value += ' }'
.      endif
.  endfor
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling Unions..."
.for Union as s
.  for root->GCC_XML. as f where f.context?'' = s.id
.    move f to s
.-   echo " Moving $(name(f):) ofType:$(f.type?'') -> $(f.name?'<undefined>':) into Union (s.idame:)..."
.  endfor
.endfor
.echo "  Handling Class (context)..."
.for Class as s
.  typedef_object = root->GCC_XML->Typedef(type = s.id)?
.  if defined(typedef_object)
.    s.base_typedef_name = typedef_object.name
.    s.base_typedef_id   = typedef_object.id
.  endif
.  for root->GCC_XML. as f where f.context?'' = s.id
.    if f.name?'not-set' = 'value_type' | f.name?'not-set' = 'key_type' | f.name?'not-set' = 'mapped_type'
.      copy f to s
.    endif
.-   echo " Copying $(name(f):) ofType:$(f.type?'') -> $(f.name?'<undefined>':) into Union (s.idame:)..."
.  endfor
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling Structs..."
.for Struct as s
.  if s.name = 'in_addr'
.    s.json_type = 'InAddr'
.    s.default_value = '{ 0 }'
.  elsif name = 'char'
.    s.json_type = 'Char'
.    s.default_value = "{ '\0' }"
.  else
.   s.json_type = 'Object'
.   s.default_value = '{ }'
.  endif
.  for root->GCC_XML. as f where f.context?'' = s.id
.    copy f to s
.-   echo " Copying $(name(f):) ofType:$(f.type?'') -> $(f.name?'<undefined>':) into $(s.name:)..."
.  endfor
.endfor
.- -------------------------------------------------------------------------------------------
.echo "  Handling Struct / Fields..."
.- root.save("$(filename:)-706.xml")
.for Class as c
.  if string.prefixed(c.name?'no-t-name',"vector<")
.    c.container = 'vector'
.  elsif string.prefixed(c.name?'no-t-name',"list<")
.    c.container = 'list'
.  elsif string.prefixed(c.name?'no-t-name',"map<")
.    c.container = 'map'
.  elsif string.prefixed(c.name?'no-t-name',"set<")
.    c.container = 'set'
.  endif
. endfor
.- root.save("$(filename:)-923.xml")
.- -------------------------------------------------------------------------------------------
.for Struct as s
.  s.json_type = 'Object'
.  for Field as f
.-   echo "$(f.name) .... handling ....."
.    for root->GCC_XML. as t where t.id?'' = f.type 
.        f.resolved_type = name(t)
.        if f.resolved_type = 'Class'
.          if f.container?'not-vector' = 'vector' | f.container?'not-list' = 'list' | f.container?'not-set' = 'set'
.            element_type = root->GCC_XML->$(t.parent_type)(id = t.type)?
.            if defined(element_type)
.              copy element_type to t
.            elsif f.container_type = 'std::basic_string<char>'
.              f.container_fundamental_type = 'std::string'
.              f.default_value = '""'
.              t.json_type     = 'String'
.              f.json_type     = 'String'
.              f.json_typecast = '(std::string)'
.              echo "Found $(f.container:) of std::string"
.            endif
.          elsif f.container?'not-map' = 'map'
.            echo "TODO IMPLEMENT map-container..."
.          endif
.        elsif f.resolved_type = 'Struct'
.          if string.prefixed(t.name?'no-t-name',"pair<")
.-           echo "Found pair: Setting container-type...."
.            f.container = 'pair'
.            f.container_type = 'pair'
.            f.json_type = 'Object'
.            t.json_type = 'Object'
.            for t.Field as pair_field
.              pair_type_to_element_object = root->GCC_XML->Id2Type(eid = pair_field.type)
.              pair_field.resolved_type = pair_type_to_element_object.ename
.              pair_type = root->GCC_XML->$(pair_field.resolved_type)(id = pair_field.type)
.              if defined(pair_Type)
.                copy pair_type to pair_field
.              endif
.            endfor
.          else
.            copy t to f 
.          endif
.        else
.-          echo "No special treatment $(f.name) Field.type: for $(f.resolved_type:).. YET"
.        endif
.-       echo "$(name(t)) $(f.type)"
.        f.default_value = t.default_value?'{}'
.-       ALWAYS copy the type since it might be used multiple types...
.        copy t to f
.    endfor
.  endfor
.endfor
.- -----------------------------------------------------------------------------
.- CLEANED UP Structures - run the render-functions
.- -----------------------------------------------------------------------------
.root.save("$(filename:)-cleaned.xml")
.file_id = ""
.if defined(switches.file)
.  echo "Analyzing file $(switches.file:) in $(filename:)..."
.  file_item = root->GCC_XML->File(name = switches.file)
.  if defined(file_item)
.    echo "  File $(switches.file:) has id: $(file_item.id) - generating h,cpp..."
.    file_id = file_item.id
.  endif
.else
.  abort "Passed $(switches.file:) could not be found in $(filename:) as File-element..."
.endif
.-sha1process = proc.new('sha1sum $(switches.file:) > $(switches.file:).sha1')
.-sha1retval = sha1process.run()
.sha1value = file.slurp('$(switches.file:).sha1')?'Unknown'
.
.output_file = file.basename(switches.file)
.----------------------------------------------------------------
.- Generate the h-file
.----------------------------------------------------------------
.if defined(switches.type)
.output "$(output_file:).generated.h"
.gentype = "definition"
.header(gentype,switches.file)
.for . as e where string.locate(switches.type, name(e))?-1 >= 0
.  if file_id = e.file
.    if e.name?"" <> ""
.      additional_settings = root->settings->$(name(e))(name = e.name)?
.      if additional_settings.ignore?'false' = 'true'
.        echo "  Skipping Helper-function generation of $(name(e)) -> $(e.name:)...."
.      else
.      namespaces(e,"open")
.      enum_str_from_to_functions(gentype,e)
.      struct_stream_map_functions(gentype,e,root)
.      struct_compare_functions(gentype,e,root)
.      struct_json_functions(gentype,e,root)
.      namespaces(e,"close")
.      endif
.    endif
.  endif
.endfor
.footer(gentype,switches.file)
.----------------------------------------------------------------
.- Generate the cpp-file
.----------------------------------------------------------------
.output "$(output_file:).generated.cpp"
.gentype = "implementation"
.header(gentype,switches.file)
.for . as e where string.locate(switches.type, name(e))?-1 >= 0
.  if file_id = e.file
.    if e.name?"" <> ""
.      additional_settings = root->settings->$(name(e))(name = e.name)?
.      if additional_settings.ignore?'false' = 'true'
.        echo "  Skipping Helper-function generation of $(name(e)) -> $(e.name:)...."
.      else
.      namespaces(e,"open")
.      enum_str_from_to_functions(gentype,e)
.      struct_stream_map_functions(gentype,e,root)
.      struct_compare_functions(gentype,e,root)
.      struct_json_functions(gentype,e,root)
.      namespaces(e,"close")
.      endif
.    endif
.  endif
.endfor
.footer(gentype,switches.file)
.endif
.----------------------------------------------------------------
.- Generate the test-cases
.----------------------------------------------------------------
.  output_test = file.basename(switches.file)
.output "$(output_test:)_test.cpp"
.  output_file = file.basename(switches.file)
#include "$(output_file:).generated.h"
#include <gtest/gtest.h>


.  for . as e where string.locate(switches.type, name(e))?-1 >= 0
.    if file_id = e.file
.      if e.name?"" <> ""
.        if name(e) = "Struct"
.          additional_settings = root->settings->$(name(e))(name = e.name)?
.          if additional_settings.ignore?'false' = 'true'
.            echo "  Skipping Testcase-generation of $(name(e)) -> $(e.name:)...."
.          else
.            test_structure(e)
.          endif
.        endif
.      endif
.    endif
.  endfor
.- root.save("$(filename:)-hiera.xml")